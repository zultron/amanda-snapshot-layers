#!/usr/bin/python
#
# /path/to/script [execute-on]+ [--config <config>] [--host <host>] \
#    [--disk <disk>] [--device <device>] [--level]* \
#    [--PROPERTY_NAME PROPERTY_VALUE]*

# /usr/libexec/amanda/application/script_lvsnap script_lvsnap
# PRE-DLE-AMCHECK --execute-where client --config site0-full --host
# xen0.storage0.zultron.com --disk
# /dev/data.00.0/norman.00.0.mail.amsnap --device
# /dev/data.00.0/norman.00.0.mail.amsnap --stale-seconds 86400
# --snap-suffix .amsnap

# /usr/libexec/amanda/application/script_lvsnap
# script_lvsnap POST-DLE-AMCHECK
# --execute-where client
# --config site0-full
# --host xen0.storage0.zultron.com
# --disk /dev/data.00.0/norman.00.0.mail.amsnap
# --device /dev/data.00.0/norman.00.0.mail.amsnap
# --stale-seconds 86400
# --snap-suffix .amsnap

import sys, re, os.path, pickle, time
from optparse import OptionParser
from datetime import datetime, timedelta
from time import localtime, strftime
from subprocess import Popen, PIPE
from pprint import pformat

# for XenServer
have_xenserver = True
try:
    import XenAPI, platform
except:
    have_xenserver = False

set_up_entry_points = ['pre-dle-amcheck', 'pre-dle-estimate',
                       'pre-dle-backup']
tear_down_entry_points = ['post-dle-amcheck', 'post-dle-estimate',
                          'post-dle-backup']


class Util(object):
    sudo_fail_re = re.compile(r'sudo:.*password')
    # parameters shared across instances
    parms = { 'log' : None,
              }

    def __init__(self, debug=False,
                 logfile=None,
                 log_to_stdout=False,
                 ):

        # This is set per instance
        self.debug = debug

        # The following 'parms' keys are shared between instances;
        # don't touch them at all by default, since this method will
        # be called multiple times
        
        # By default, log to stdout
        if log_to_stdout or self.parms['log'] is None:
            self.parms['log'] = sys.stdout;
        elif logfile:
            self.parms['log'] = open(logfile, 'w')

    @property
    def error_prefix(self):
        if self.params.action in ('amcheck', 'estimate'):
            return 'ERROR'
        elif self.params.action in ('backup'):
            return '?'
        else:
            return ''

    @property
    def success_prefix(self):
        if self.params.action == 'amcheck':
            return 'OK'
        elif self.params.action == 'backup':
            return '|'
        elif self.params.action == 'estimate':
            # In Script_App.pm, only the 'check' action prints 'OK' messages
            return None
        else:
            return ''

    def infomsg(self,msg):
        for line in msg.split('\n'):
            self.parms['log'].write("%s\n" % line)

    def debugmsg(self,msg):
        if self.debug:
            self.infomsg(msg)

    def statusmsg(self,msg,error=False):
        if error:
            prefix = self.error_prefix
        else:
            prefix = self.success_prefix
        if prefix is None:
            return
        for line in [ "%s %s\n" % (prefix, l) for l in msg.split('\n') ]:
            self.parms['log'].write(line)
            if self.parms['log'] is not sys.stdout:
                sys.stdout.write(line)

    def error(self,msg):
        self.statusmsg(msg, error=True)
        sys.exit(1)

    def _print_io(self,prefix,output,debug=True):
        for line in [l for l in output.rstrip().split('\n') if l]:
            if debug:
                self.debugmsg(prefix + line)
            else:
                self.infomsg(prefix + line)

    def run_cmd(self,cmd,sudo=True,t_f=True,fail_abort=True):
        # cmd may be a string (bad) or an array (good)
        if type(cmd) is str:
            cmd = cmd.split()
        if sudo:
            cmd = ['sudo', '-n'] + cmd

        # run cmd, capturing stdin, stdout and exit status
        self.debugmsg("        Running command:  %s" % ' '.join(cmd))
        popen_obj = Popen(cmd, stdout=PIPE, stderr=PIPE)
        (stdout, stderr) = popen_obj.communicate()

        # when t_f is True, return True/False; otherwise, integer exit status
        if t_f:
            res = popen_obj.returncode == 0
        else:
            res = popen_obj.returncode

        # when running sudo, if the sudo command fails,
        #   if fail_abort is True, print debug messages and error out;
        #   otherwise, return None for calling routine to handle
        if sudo and self.sudo_fail_re.match(stderr):
            if fail_abort:
                self.infomsg("Command failed, aborting:")
                self.infomsg("              exit:  %s" % popen_obj.returncode)
                self._print_io("            stdout:  ", stdout)
                self._print_io("            stderr:  ", stderr)
                sys.exit(1)
            else:
                res = None

        # print debugging info
        self.debugmsg("            exit/return:  %s/%s" %
                      (popen_obj.returncode,res))
        self._print_io("            stdout:  ", stdout, debug=True)
        self._print_io("            stderr:  ", stderr, debug=True)

        return (res,stdout,stderr)


class Params(object):

    required_params = ['stale_seconds', 'mount_base', 'size', 'device']
    optional_params = ['debug', 'log_to_stdout', 'config', 'host', 'disk',
                       'layer_param_field_sep', 'level', 'execute_where']
    all_params = required_params + optional_params
    interesting_params = ['device', 'disk', 'stale_seconds', 'mount_base',
                          'size', 'debug', 'log_to_stdout',
                          'layer_param_field_sep']

    def __init__(self,
                 set_up_entry_points,
                 tear_down_entry_points):

        self.set_up_entry_points = set_up_entry_points
        self.tear_down_entry_points = tear_down_entry_points

        # basic command line option parsing and sanity checks
        self.usage = "usage:  %prog [execute-on]+ [options]"
        self.parse_options()
        self.check_args()
        self.check_required_params()
        self.check_device_param()

        self.util = Util(debug=self.debug,
                         logfile = self.logfile,
                         log_to_stdout = self.log_to_stdout)


    def parse_options(self):
        parser = OptionParser(usage=self.usage)

        # custom properties
        parser.add_option("--stale_seconds", "--stale-seconds", type="int",
                          help=("number of seconds before a snapshot is "
                                "considered stale"))
        parser.add_option("--mount_base", "--mount-base",
                          help=("base directory to mount snapshot"))
        parser.add_option("--no_auto_mount", "--no-auto-monut",
                          help=("don't automatically try to automount the "
                                "final device; mount must be specified "
                                "explicitly"))
        parser.add_option("--size",
                          help=("size of snapshot; see lvcreate(8) for units"))
        parser.add_option("--debug", type="int",
                          help=("Print debug output; param is 0 or 1"))
        parser.add_option("--log_to_stdout", "--log-to-stdout",
                          action="store_true", default=False,
                          help=("output to stdout for debugging"))
        parser.add_option("--layer_param_field_sep", "--layer-param-field-sep",
                          default=',=+',
                          help=("separator charactors for "
                                "layers, params and fields (default ',=+')"))

        # standard properties
        parser.add_option("--device",
                          help=("mount directory with embedded device layering "
                                "scheme: <mount_base>/"
                                "(lvm=<vg+lv>|raid1|part=<part#>)[,<...>]/"))
        parser.add_option("--config",
                          help="amanda configuration")
        parser.add_option("--host",
                          help="client host")
        parser.add_option("--disk",
                          help="disk to back up")
        parser.add_option("--level", type="int",
                          help="dump level")
        parser.add_option("--execute_where", "--execute-where",
                          help="where this script is executed")

        (self.params, self.args) = parser.parse_args()
        self.parser = parser

        # link params into this object for convenience
        for p in self.all_params:
            try:
                setattr(self,p,getattr(self.params,p,None))
            except AttributeError:
                # can't set 'debug' attribute; it's a property defined below
                pass

    def check_args(self):
        if len(self.args) != 1:
            self.parser.error("must have exactly one arg; found %d" %
                              len(self.args))

    def check_required_params(self):
        for param in self.required_params:
            if not getattr(self.params, param):
                self.parser.error("Required parameter '%s' missing" % param)

    def check_device_param(self):
        if not self.device.startswith(
            self.params.mount_base + "/"):
            self.parser.error("device path must begin with "
                              "the base mount directory")

    def print_params(self):
        self.util.infomsg("\nCommand line argument parsing results:")
        for p in self.interesting_params:
            self.util.infomsg(" %25s: %s" % (p, getattr(self,p,None)))
        self.util.infomsg("\nScheme:")
        for layer in self.scheme:
            if len(layer) == 2:
                self.util.infomsg(" %-15s %s" % (layer[0], layer[1]))
            else:
                self.util.infomsg(" %s" % layer[0])
        self.util.infomsg("")
        
    @property
    def debug(self):
        return self.params.debug == 1

    @property
    def scheme(self):
        target_string = self.params.device[
            len(self.params.mount_base)+1:]

        # e.g. [['lvm', 'vg+lv'], ['raid1'], ['part', '1']]
        # (param values like for lvm are split within the params' respective
        # handling code)
        scheme = [i.split(self.layer_param_field_sep[1])
                  for i in target_string.split(self.layer_param_field_sep[0])]
        return scheme

    @property
    def field_sep(self):
        return self.layer_param_field_sep[2]

    @property
    def entry_point(self):
        return self.args[0].lower()

    @property
    def entry_point_split(self):
        return self.entry_point.split('-')

    @property
    def set_up_mode(self):
        return self.entry_point in self.set_up_entry_points

    @property
    def tear_down_mode(self):
        return self.entry_point in self.tear_down_entry_points

    @property
    def action(self):
        return self.entry_point_split[-1]

    @property
    def pre_post(self):
        return self.entry_point_split[1]

    @property
    def logfile(self):
        return '/var/log/amanda/amandad/lvsnap.%s.%s.%s.debug' % \
               (strftime("%Y%m%d%H%M%S", localtime()),
                self.params.disk, self.entry_point)


class Snapdb(dict):
    '''
    pickled dict of snapshot creation timestamps persisted to a file
    '''

    picklefile = '/var/lib/amanda/lvsnap.db'
    epoch = datetime(1971,01,01)

    def __init__(self,debug=False):
        self.util = Util()
        if os.path.exists(self.picklefile):
            try:
                self.update(pickle.load(open(self.picklefile, 'r')))
            except:
                self.util.error("Error reading snapshot db '%s': %s" %
                      (self.picklefile, sys.exc_info()[0]))
        self.util.debugmsg("Read pickled DB: %s" % pformat(self))

    def save(self):
        try:
            pickle.dump(self,open(self.picklefile, 'w'))
        except:
            self.util.error("Error writing snapshot db '%s':\n%s" %
                            (self.picklefile, sys.exc_info()[0]))

    def record_snap(self,snap_device):
        self.setdefault(snap_device,{})['timestamp'] = datetime.now()
        self.save()

    def delete_snap(self,snap_device):
        self[snap_device] = {}
        self.save()

    def timestamp(self,device,set_default=False):
        if self.setdefault(device,{}).has_key('timestamp'):
            return self[device]['timestamp']
        else:
            if set_default:
                return self.epoch
            else:
                return None

    def is_expired(self,device,stale_seconds,nodefault=False):
        if not nodefault and self.timestamp(device) is None:
            return None
        else:
            return (datetime.now() - timedelta(seconds=stale_seconds)) > \
                   self.timestamp(device,True)
           

class Layer(Util):
    class_params = {
        'snapdb' : None,
        }

    def __init__(self, arg_str, params, parent_layer):

        super(Layer, self).__init__(
            debug = params.debug)

        self.arg_str = arg_str
        self.params = params
        self.parent = parent_layer

    @property
    def snapdb(self):
        if self.class_params['snapdb'] is None:
            self.class_params['snapdb'] = Snapdb(debug = self.debug)
        return self.class_params['snapdb']

    @property
    def parent_device(self):
        return self.parent.device

    @property
    def is_stale(self):
        if self.parent_device is None:
            self.error("class %s does not implement is_stale method" %
                       self.__class__.__name__)
        return self.parent.is_stale
    
    @property
    def is_setup(self):
        self.error("class %s does not implement is_setup method" %
                       self.__class__.__name__)
    
    def safe_teardown(self):
        self.error("class %s does not implement safe_teardown method" %
                       self.__class__.__name__)

    def safe_setup(self):
        self.error("class %s does not implement safe_setup method" %
                       self.__class__.__name__)

class Snapper(Layer):
    lvcreate = '/usr/sbin/lvcreate'
    lvremove = '/usr/sbin/lvremove'
    lvdisplay = '/usr/sbin/lvdisplay'
    snap_suffix = '.amsnap'
    name = 'lvm'

    def print_info(self):
        self.infomsg("Initialized LVM snapshot object parameters:")
        self.infomsg("    target device = %s" % self.lv_device)
        self.infomsg("    snapshot device = %s" % self.device)
        self.infomsg("    stale seconds = %d" % self.stale_seconds)
        self.infomsg("    snapshot size = %s" % self.size)


    @property
    def stale_seconds(self):
        return self.params.stale_seconds

    @property
    def size(self):
        return self.params.size

    @property
    def vg_name(self):
        return self.arg_str.split(self.params.field_sep)[0]

    @property
    def lv_name(self):
        return self.arg_str.split(self.params.field_sep)[1]

    @property
    def lv_device(self):
        return "/dev/%s/%s" % (self.vg_name, self.lv_name)
        

    @property
    def device(self):
        return self.lv_device + self.snap_suffix

    @property
    def snap_exists(self):
        cmd = [self.lvdisplay, '-c', self.device]
        (res,stdout,stderr) = self.run_cmd(cmd)
        return res

    @property
    def orig_exists(self):
        cmd = [self.lvdisplay, '-c', self.lv_device]
        (res,stdout,stderr) = self.run_cmd(cmd)
        return res

    @property
    def is_snapshot(self):
        cmd = ['lvs', '--noheadings', '-o', 'lv_attr', self.device]
        (res,stdout,stderr) = self.run_cmd(cmd)
        return stdout.lstrip().rstrip().lower()[0] == 's'

    @property
    def matches_target(self):
        cmd = ['lvs', '--noheadings', '-o', 'origin', self.device]
        (res,stdout,stderr) = self.run_cmd(cmd)
        return stdout.lstrip().rstrip() == self.lv_name

    @property
    def is_stale(self, nodefault=False):
        return self.snapdb.is_expired(self.device, self.stale_seconds)

    @property
    def in_snapdb(self):
        return self.snapdb.is_expired(self.device,
                                      self.stale_seconds,
                                      nodefault=True) is not None

    @property
    def is_setup(self):
        # no sanity checks here, just if the snap exists or not;
        # good enough to know if tearing down is needed
        return self.snap_exists

    def create_snapshot(self):
        cmd = [self.lvcreate, '-s', '-n', self.device,
               '-L', self.size, self.lv_device]
        (res,stdout,stderr) = self.run_cmd(cmd)

        self.snapdb.record_snap(self.device)

        self.infomsg("  Ran 'lvcreate' command")
        
    def remove_snapshot(self):
        # delete the snapshot
        cmd = [self.lvremove, '-f', self.device]
        (res,stdout,stderr) = self.run_cmd(cmd)

        self.snapdb.delete_snap(self.device)

        self.infomsg("  Ran 'lvremove' command")

    def safe_set_up(self):

        self.infomsg("Setting up snapshot")
        not_exist=False

        # sanity check:  the original disk should exist
        if not self.orig_exists:
            self.error("target LV does not exist:  %s" %
                       self.lv_device)
        self.debugmsg("  Sanity check passed:  target LV exists")

        # Existing snapshots need sanity and staleness checks
        if self.snap_exists:
            self.infomsg("Found existing snapshot %s" % self.device)

            # sanity check:  existing snapshot's origin must be target device
            if not self.matches_target:
                self.error("Existing snapshot's origin is not target device; "
                           "aborting")
            self.debugmsg("  Sanity check passed:  "
                          "snapshot's origin matches target")

            # sanity check:  existing snapshots must be in db
            if not self.in_snapdb:
                self.error("Existing snapshot not found in database; aborting")
            self.debugmsg("  Sanity check passed:  snapshot found in database")

            # sanity check:  snapshots should be snapshots!
            if not self.is_snapshot:
                self.error("Device %s is not a snapshot; aborting" %
                           self.device)
            self.debugmsg("  Sanity check passed:  snapshot is a snapshot device")

            # remove stale snapshots
            if self.is_stale:
                self.infomsg("Snapshot is stale")
                # FIXME unimplemented; for now, just abort
                self.error("delete_snapshot() not implemented; aborting")
                #unmount_and_remove_snapshot(util, snapper)
        else:
            not_exist = True
            self.debugmsg("  Sanity check passed:  "
                          "Snapshot does not already exist")

        # Create snapshot if it doesn't exist (or was expired)
        if not_exist or not self.snap_exists:
            self.create_snapshot()
            # Check one last time
            if not self.snap_exists:
                self.error("Failed to create snapshot; aborting")

        self.infomsg("Snapshot successfully set up\n")

    def safe_teardown(self):

        self.infomsg("Removing snapshot")

        # sanity check:  snapshot should exist
        if not self.snap_exists:
            self.infomsg("Snapshot does not exist; not removing")
            return
        self.debugmsg("  Sanity check passed:  snapshot exists")

        # Sanity check: check target really is a snapshot
        if not self.is_snapshot:
            self.error("Snapshot is not a snapshot device; aborting")
        self.debugmsg("  Sanity check passed:  snapshot is a snapshot device")

        # Remove snapshot
        self.remove_snapshot()

        # Check one last time
        if self.snap_exists:
            self.error("Failed to remove snapshot; aborting")
        else:
            self.infomsg("Successfully removed snapshot\n")



class XenVDISnapper(Snapper):
    '''
    Given a VDI name-label and snapshot name, create a snapshot

    /v/amanda.mount/xenvdi=junction.root.0,raid1,part=1
    '''

    def __init__(self,arg_str,params,parent_layer):

        super(XenVDISnapper,self).__init__(arg_str,params,parent_layer)

        if not have_xenserver:
            self.error("Tried to init XenVDISnapper, but XenAPI libs "
                       "not available")

        self.init_xenapi_session()

    def print_info(self):
        self.infomsg("Initialized Xen VDI snapshot object parameters:")
        self.infomsg("    VDI name-label = %s" % self.vdi_name_label)
        self.infomsg("    target device = %s" % self.lv_device)
        self.infomsg("    snapshot device = %s" % self.device)
        self.infomsg("    stale seconds = %d" % self.stale_seconds)
        self.infomsg("    snapshot size = %s" % self.size)

        
    def init_xenapi_session(self):
        self.session = XenAPI.xapi_local()
        self.session.xenapi.login_with_password('root', '')
        #self.session = XenAPI.Session('http://%s' % self.hostname)
        #session.xenapi.login_with_password(self.username, self.password)

    @property
    def vdi_name_label(self):
        return self.arg_str

    @property
    def vdi_record(self):
        for (key, val) in self.session.xenapi.VDI.get_all_records().items():
            if val['name_label'] == self.vdi_name_label:
                return val
        return None

    @property
    def sr_record(self):
        try:
            sr = self.session.xenapi.SR.get_record(self.vdi_record['SR'])
        except Exception, e:
            self.error("Unable to get SR:  %s" % e)
        return sr

    @property
    def lv_device(self):
        return '/dev/VG_XenStorage-%s/VHD-%s' % ( self.sr_record['uuid'],
                                                  self.vdi_record['uuid'] )
    


class MD_component_device(Layer):
    '''
    A Linux md RAID1 device (other raid levels not supported)

    This class detects and assembles/disassembles RAID1 mirrors in
    degraded mode (half device) for backups
    '''

    name = 'raid1'
    mdadm = '/sbin/mdadm'
    raid1_re = re.compile(r' level=raid1 ')
    uuid_re = re.compile(r'UUID=([0-9a-f:]+)')
    md_dev_re = re.compile(r'^md([0-9]+)$')

    def __init__(self,arg_str,params,parent_layer):
        super(MD_component_device,self).__init__(arg_str,params,parent_layer)
        self.md_dev = None
        self.dev_uuid = None
        self.dev_db = None
        self.found_md_raid1_device = None

    def print_info(self):
        self.infomsg("Initialized md component device object parameters:")
        self.infomsg("    component device = %s" % self.parent_device)

    def md_device_exists(self,device=None):
        if device is None:
            device = self.md_device
        return os.path.exists(device)

    @property
    def device_exists(self):
        return os.path.exists(self.parent_device)

    def _extract_uuid(self,line):
        s = self.uuid_re.search(line)
        if s is None:
            return None
        return s.groups()[0]

    def _other_md_device_running(self, md_device,
                                 return_all_results=False, fail_abort=False):
        cmd = [self.mdadm, '-D', md_device, '-b']
        (res,stdout,stderr) = self.run_cmd(
            cmd, sudo=True, t_f=True, fail_abort=fail_abort)
        if return_all_results:
            return (res,stdout,stderr)
        else:
            return res

    def in_running_md_device(self,recheck=False):

        # don't re-run check unless told to
        if self.md_dev is not None:
            if self.md_dev == -1:
                return None
            else:
                return self.md_dev

        # get md array UUID for matching
        my_uuid = self.get_uuid

        # reset dev_db
        self.dev_db = {}

        for devnum in [int(i[2:]) for i in os.listdir("/dev")
                       if self.md_dev_re.match(i)]:
            md_dev = '/dev/md%d' % devnum

            (res, stdout, stderr) = \
                  self._other_md_device_running(md_dev, return_all_results=True)
            if res is None:
                self.dev_db[md_dev] = -1
                self.debugmsg(
                    "     failed to check device %s; ignoring" % md_dev)
                continue
            if not res:
                self.dev_db[md_dev] = 0
                self.debugmsg(
                    "     Device %s not running; ignoring" % md_dev)
                continue

            uuid = self._extract_uuid(stdout)
            if uuid is None:
                self.dev_db[md_dev] = -1
                self.debugmsg("     Unable to determine UUID for device %s; "
                              "ignoring" % md_dev)
                continue
            if uuid == my_uuid:
                self.md_dev = md_dev
                self.dev_db[md_dev] = 1
                self.debugmsg("  Target device is member of "
                              "running md device %s" % self.md_dev)
                return self.md_dev
        
            self.debugmsg("     Device %s does not contain our component "
                          "device; ignoring" % md_dev)

        self.md_dev = -1
        return None


    @property
    def is_md_raid1_component_device(self):
        # don't check again
        if self.found_md_raid1_device is not None:
            return True

        cmd = [self.mdadm, '-Q', self.parent_device, '--examine', '-b']
        (res,stdout,stderr) = self.run_cmd(cmd)
        self.found_md_raid1_device = (res and
                                      self.raid1_re.search(stdout) is not None)

        return self.found_md_raid1_device

    @property
    def get_uuid(self):
        if self.dev_uuid is not None:
            return self.dev_uuid

        cmd = [self.mdadm, '-Q', '--examine', self.parent_device, '-b']
        (res,stdout,stderr) = self.run_cmd(cmd)
        self.dev_uuid = self._extract_uuid(stdout)
        if self.dev_uuid is None:
            self.error("unable to determine md device UUID for %s" %
                       self.parent_device)
        self.debugmsg("  Found snapshot array UUID = %s" % self.dev_uuid)
        return self.dev_uuid

    @property
    def md_device(self):
        # if part of a running md array, return that
        if self.in_running_md_device() is not None:
            return self.in_running_md_device()

        # otherwise, find an unused md device
        for i in xrange(10):
            candidate_dev = "/dev/md%d" % i
            if self.dev_db.get(candidate_dev,None) is not None:
                continue
            if not self.md_device_exists(candidate_dev):
                self.md_dev = candidate_dev
                self.debugmsg("  Selecting unused md device %s" %
                              candidate_dev)
                break
            cand_status = self._other_md_device_running(candidate_dev)
            if cand_status is None:
                self.debugmsg("    Ignoring uncheckable md device %s" %
                              candidate_dev)
            elif cand_status is True:
                self.debugmsg("    md device %s in use" % candidate_dev)
            else:
                self.md_dev = candidate_dev
                self.debugmsg("    Found unused md device %s" % candidate_dev)
                break
        if self.md_dev is None:
            self.error("Unable to find unused md device node; aborting")
        return self.md_dev

    @property
    def device(self):
        if self.is_setup:
            return self.md_device
        else:
            return None

    @property
    def md_device_running(self):
        return self._other_md_device_running(self.md_dev)

    @property
    def is_setup(self):
        return self.in_running_md_device(recheck=True) is not None

    def assemble_md_device(self):
        cmd = [self.mdadm, '-A', self.md_device, self.parent_device, '--run']
        (res,stdout,stderr) = self.run_cmd(cmd)

    def stop_md_device(self):
        cmd = [self.mdadm, '-S', self.md_device]
        (res,stdout,stderr) = self.run_cmd(cmd)
        self.infomsg("  Ran 'mdadm -S' command")
        
    def safe_set_up(self):
        self.infomsg("Assembling md array")

        # sanity check:  snapshot device is an md array component
        if not self.is_md_raid1_component_device:
            self.error("Device %s is not an md RAID1 "
                       "component device; aborting" % self.parent_device)
        self.debugmsg("  Sanity check passed:  "
                      "device is an md RAID1 component device")

        # if snapshot device is part of a running md array, nothing to do
        if self.in_running_md_device():
            self.infomsg("Device is already part of running md array\n")
            return
        self.debugmsg("  Device not already part of any running md array")

        self.assemble_md_device()
        self.infomsg("  Ran 'mdadm -A %s' command" % self.md_device)

        # check device status
        if not self.md_device_exists:
            self.error("md device %s does not exist after assembly; aborting" %
                       self.md_device)
        self.debugmsg("  Sanity check passed:  md device exists")

        if not self.md_device_running:
            self.error("md device %s exists but not running after assembly; "
                       "aborting" % self.md_device)
        self.debugmsg("  Sanity check passed:  md device running")

        self.infomsg("Successfully started md array\n")



    def safe_teardown(self):
        self.infomsg("Stopping md array")

        # if component device is not running, there's nothing to do
        if not self.device_exists:
            self.infomsg("Component device does not exist; nothing to stop\n")
            return
        self.debugmsg("  Sanity check passed:  md component device exists")

        # if md array is not running, there's nothing to do
        if not self.in_running_md_device():
            self.infomsg("Device is not part of any running md array; "
                         "nothing to stop\n")
            return
        self.debugmsg("  Sanity check passed:  "
                      "device is component of running array")

        # FIXME: unimplemented
        # sanity check:  snapshot device is component of the array we just
        # unmounted
        
        #if not self.is_component_device_of(md_dev):
        #    self.error("Device is not a component device of the array; "
        #               "aborting")

        self.stop_md_device()

        # check device status
        if self.md_device_running:
            self.error("md device %s still running after stopping; "
                       "aborting" % self.md_device)
        self.debugmsg("  Sanity check passed:  md device not still running")

        #if self.md_device_exists():
        #    self.error("md device file %s still exists after stopping; "
        #               "aborting" % self.md_device)
        #self.debugmsg("  Sanity check passed:  md device no longer exists")

        self.infomsg("Stopped md array %s\n" % self.in_running_md_device())

        # reset attributes in case the object is reused
        self.md_dev = None
        self.dev_uuid = None
        self.dev_db = None




class Mount(Layer):
    name = 'mount'
    mount_cmd = '/bin/mount'
    umount_cmd = '/bin/umount'

    def __init__(self,arg_str,params,parent_layer):

        super(Mount,self).__init__(arg_str,params,parent_layer)

        self.mount_db = None


    def print_info(self):
        self.infomsg("Initialized mount object parameters:")
        # Don't print parent_device; this invokes unwanted mdadm runs
        # if the underlying RAID1 layer isn't set up
        #self.infomsg("    device = %s" % self.parent_device)
        self.infomsg("    mount point = %s" % self.mount_point)
        self.infomsg("    base mount directory = %s" % self.mount_base)
        self.infomsg("    real base mount directory = %s" %
                     self.real_mount_base)

    @property
    def parent_device(self):
        # handle partitioned parent device
        if self.arg_str and self.arg_str != '0':
            # if parent is RAID1, partitions will be created as e.g. /dev/md1p1
            if isinstance(self.parent, MD_component_device):
                return "%sp%s" % (self.parent.device, self.arg_str)
            else:
                self.error("Don't know how to handle supplied partition "
                           "argument '%s'" % self.arg_str)
        else:
            return self.parent.device

    @property
    def mount_point(self):
        return self.params.device

    @property
    def mount_base(self):
        return self.params.mount_base

    @property
    def mount_re(self):
        if getattr(self,'mount_re_compiled',None) is None:
            self.mount_re_compiled =  re.compile(
                r'^([^ ]*) (%s/[^ ]*)' %
                os.path.realpath(self.real_mount_base))
        return self.mount_re_compiled

    @property
    def real_mount_base(self):
        return os.path.realpath(self.mount_base)

    def device_exists_wait(self,timeout):
        res = False
        for i in xrange(timeout+1):
            res = os.path.exists(self.parent_device)
            if res:
                break
            time.sleep(0.1)
        return res

    @property
    def device_exists(self):
        return os.path.exists(self.parent_device)

    @property
    def device(self):
        if self.is_setup:
            return self.mount_point
        else:
            return None

    @property
    def mount_point_exists(self):
        if not os.path.exists(self.mount_point):
            # try to create it
            cmd = ['mkdir', self.mount_point]
            (res,stderr,stdout) = self.run_cmd(cmd)
            if not res:
                error("Unable to create mount point '%s':\n%s" %
                      (self.mount_point, stderr))
            self.debugmsg("  Created mount point directory %s" %
                          self.mount_point)
        return True

    def remove_mount_point(self):
        if os.path.exists(self.mount_point):
            (res,stderr,stdout) = self.run_cmd(['rmdir', self.mount_point])
            if not res:
                error("Unable to remove mount point '%s':\n%s" %
                      (self.mount_point, stderr))
            self.debugmsg("  Removed mount point directory %s" %
                          self.mount_point)

    @property
    def mount_point_is_directory(self):
        return os.path.isdir(self.mount_point)

    @property
    def real_mount_point(self):
        return os.path.realpath(self.mount_point)

    def build_mount_db(self, rebuild=False):
        if not rebuild and self.mount_db is not None:
            return self.mount_db

        self.mount_db = { 'mount_dev' : {},
                          'mount_point' : {} }

        try:
            fd = open('/proc/mounts','r')
            for line in fd:
                m = self.mount_re.match(line)
                if m is None:
                    continue
                self.mount_db['mount_dev'][m.groups()[0]] = m.groups()[1]
                self.mount_db['mount_point'][m.groups()[1]] = m.groups()[0]
                self.debugmsg("    found mount '%s' -> '%s'" %
                              m.groups())
        except:
            self.error("Unable to read /proc/mounts")

        return self.mount_db

    def mount_point_to_mount_dev(self,mount_point):
        return self.build_mount_db()['mount_point'].get(mount_point,None)

    def mount_dev_to_mount_point(self,mount_dev):
        return self.build_mount_db()['mount_dev'].get(mount_dev,None)

    @property
    def is_mounted(self):
        return self.mount_point_to_mount_dev(self.real_mount_point) == \
               self.parent_device

    @property
    def is_mounted_by_something(self):
        return self.mount_point_to_mount_dev(self.real_mount_point) is not None

    @property
    def is_mounted_by_other(self):
        return not self.is_mounted and self.is_mounted_by_something

    @property
    def mount_device(self):
        return self.mount_point_to_mount_dev(self.real_mount_point)

    def do_mount(self):
        cmd = [self.mount_cmd, '-r', self.parent_device, self.mount_point]
        (res,stdout,stderr) = self.run_cmd(cmd)
        self.build_mount_db(rebuild=True)
        if not res:
            self.error("Mount command failed:  %s" % stderr)

    def do_umount(self):
        cmd = [self.umount_cmd, self.mount_point]
        (res,stdout,stderr) = self.run_cmd(cmd)
        self.build_mount_db(rebuild=True)
        if not res:
            self.error("Mount command failed:  %s" % stderr)

    @property
    def is_setup(self):
        return self.is_mounted


    def safe_set_up(self):
        self.infomsg("Mounting device %s onto %s" %
                         (self.parent_device, self.mount_point))
            
        # sanity check:  if device already mounted, nothing to do
        if self.is_mounted:
            self.infomsg("Device already mounted; nothing to do\n")
            return
        self.debugmsg("  Sanity check passed:  device not already mounted")

        # sanity check:  device exists (wait up to two seconds for device
        # to appear)
        if not self.device_exists_wait(20):
            self.error("Cannot mount non-existent device %s" %
                       self.parent_device)
        self.debugmsg("  Sanity check passed:  device exists")

        # sanity check:  ensure mount point exists
        if not self.mount_point_exists:
            self.error("Mount point non-existent, and failed to create: %s" %
                       self.mount_point)
        self.debugmsg("  Sanity check passed:  mount point exists")

        # sanity check:  ensure mount point is a directory
        if not self.mount_point_is_directory:
            self.error("Mount point exists but is not a directory")
        self.debugmsg("  Sanity check passed:  mount point is a directory")

        # sanity check:  ensure mount point is not already mounted upon
        if self.is_mounted_by_other:
            self.error("Mount point already mounted upon")
        self.debugmsg("  Sanity check passed:  "
                      "mount point not already mounted upon")

        # do the mount
        self.do_mount()
        self.infomsg("  Ran 'mount' command")

        # sanity check:  ensure device is now mounted
        if not self.is_mounted:
            self.error("Device is not mounted")
        self.infomsg("Device successfully mounted\n")

    def safe_teardown(self):
        self.infomsg("Unmounting directory %s" % self.parent_device)

        # sanity check:  if mount point not mounted upon, nothing to do
        if not self.is_mounted_by_something:
            self.infomsg("Mount point not mounted upon; nothing to do\n")
            return
        self.debugmsg("  Sanity check passed:  mount point is mounted upon")

        # do the umount
        self.do_umount()
        self.infomsg("  Ran 'umount' command")

        # remove the mount directory
        self.remove_mount_point()

        # sanity check:  ensure device is now unmounted
        if self.is_mounted_by_something:
            self.error("Device is still mounted; umount failed")
        self.infomsg("Device successfully unmounted\n")


class Stack(Util):

    dispatch_hash = {
        'lvm' : Snapper,
        'xenvdi' : XenVDISnapper,
        'raid1' : MD_component_device,
        'part' : Mount,
        }

    def __init__(self,params,debug=None):
        # set up utils; we expect logging to already be set up from 'params'
        super(Stack, self).__init__(debug=params.debug)
        if debug is not None:
            self.debug = debug

        self.params = params

        # after a check(), these will be True or False
        self.is_setup = None
        self.is_stale = None

        # after a check(), this will be the top layer found to be set up
        self.top_set_up_layer = None

        self.layers = []
        parent_layer = None
        for layer in params.scheme:
            if not self.dispatch_hash.has_key(layer[0]):
                self.error("Unrecognized layer name '%s'" % layer[0])
            self.layers.append(
                self.dispatch_hash[layer[0]](
                (layer+[None])[1], self.params, parent_layer))
            parent_layer = self.layers[-1]
            parent_layer.print_info()
            self.infomsg('')

        # if top isn't a Mount object, add one, assuming an unpartitioned
        # block device with a mountable filesystem
        if not isinstance(self.layers[-1], Mount):
            self.layers.append(Mount('0', self.params, parent_layer))
            self.layers[-1].print_info()
            self.infomsg('')

    def check(self):
        self.is_stale = False
        self.is_setup = True
        for layer in self.layers:
            self.debugmsg("Checking layer %s, args %s" %
                          (layer.name, layer.arg_str))
            if layer.is_setup:
                self.top_set_up_layer = layer
                if layer.is_stale:
                    self.debugmsg("Layer '%s' set up but stale\n" %
                                  layer.name)
                    self.is_stale = True
                else:
                    self.debugmsg("Layer '%s' set up and not stale\n" %
                                  layer.name)
            else:
                self.is_setup = False
                self.debugmsg("Layer '%s' not set up; end of check\n" %
                              layer.name)
                # don't continue; uninitialized lower layers aren't required
                # to provide a parent device for higher layers
                break

    @property
    def is_torn_down(self):
        if self.is_setup is None:
            self.check()
        return self.top_set_up_layer is None

    def tear_down(self):
        if self.is_setup is None:
            self.error("Stack tear_down() method called before "
                       "check(); aborting")
        while self.top_set_up_layer is not None:
            layer = self.top_set_up_layer
            self.top_set_up_layer = layer.parent
            layer.safe_teardown()

    def set_up(self):
        if self.is_setup is None:
            self.error("Stack set_up() method called before "
                       "check(); aborting")
        for layer in self.layers:
            layer.safe_set_up()


def main():

    # command line option processing
    params = Params(set_up_entry_points,
                    tear_down_entry_points)

    # print debug info
    if params.debug:
        params.print_params()

    # pull util object out for easy access
    util = params.util

    # set up stack object
    stack = Stack(params)

    # setting up
    if params.set_up_mode:
        util.infomsg("\nEntry point = %s; set-up mode\n" % params.entry_point)
        # check the stack
        stack.check()
        if not stack.is_setup:
            if stack.is_torn_down:
                util.infomsg("Stack not set up\n")
            else:
                util.infomsg("Stack partially set up to %s; tearing down\n" %
                         stack.top_set_up_layer.name)
                # tear it down
                stack.tear_down()
                # confirm torn down
                if not stack.is_torn_down:
                    util.error("Stack not torn down; aborting")
                util.infomsg("Successfully tore down partially set up stack; "
                             "rechecking\n")
                stack.check()
        elif stack.is_stale:
            util.infomsg("Stack is stale; tearing down\n")
            stack.tear_down()
            # tear it down; confirm torn down
            if not stack.is_torn_down:
                util.error("Stack not torn down; aborting")
            util.infomsg("Successfully tore down stale stack; rechecking\n")
            stack.check()
        else:
            util.infomsg("Stack is set up; nothing to do")
            sys.exit(0)

        # Set up stack
        stack.set_up()

        util.infomsg("Successfully set up stack")
        sys.exit(0)

    elif params.tear_down_mode:
        util.infomsg("\nEntry point = %s; tear-down mode\n" %
                     params.entry_point)
        # check the stack
        stack.check()

        # if stack is set up, tear it down
        if not stack.is_torn_down:
            if stack.is_setup:
                util.infomsg("Stack is set up; tearing down\n")
            else:
                util.infomsg("Stack partially set up to %s layer; "
                             "tearing down" % stack.top_set_up_layer.name)
            stack.tear_down()
            
        util.infomsg("Successfully tore down stack\n")
    else:
        util.error("Unable to determine what to do.  Aborting.")

    sys.exit(0)


if __name__ == "__main__":
    main()
